# NanopolishComp 0.4 package documentation
---

**Python3 package for upstream preprocessing and downstream analyses of nanopolish**

---

* Author: Adrien Leger - aleg {at} ebi.ac.uk
* URL: https://github.com/a-slide/NanopolishComp
* Licence: MIT
* Python version: >=3.3

# Installation

Ideally, before installation, create a clean python3 virtual environment to deploy the package, using virtualenvwrapper for example (see http://www.simononsoftware.com/virtualenv-tutorial-part-2/).

## Required python packages:

[Nanopolish 0.10+](https://github.com/jts/nanopolish) is required to generate the files used by several commands from this package

All python dependencies are automatically installed with pip

## Installation with pip

Ideally, before installation, create a clean python3 virtual environment to deploy the package, using virtualenvwrapper for example (see http://www.simononsoftware.com/virtualenv-tutorial-part-2/).

* To install the package

    ```pip3 install git+https://github.com/a-slide/NanopolishComp.git```

* To update the package:

    ```pip3 install git+https://github.com/a-slide/NanopolishComp.git --upgrade```

## Command list

### Eventalign_collapse

This program collapses the raw file generated by **nanopolish eventalign** by kmers rather than by event.

Contrary to **nanopolish eventalign** output text file, in **Eventalign_collapse** the reads are separated by a hashtag headers containing the read_id and ref_id. This reduces the redundancy and makes it easier to find the start and end of a read.

Example : ```#7ef1d7b9-5824-4382-b23b-78d82c07ebbd	YHR055C.```

The main data file contains the following fields:

* ref_pos: Reference sequence ID (contig).
* ref_kmer: Sequence of the reference kmers.
* n_events: Number of events for this kmer before collapsing.
* NNNNN_events: Number of events for which the model sequence was "NNNNN" for this kmer before collapsing (event ignored by nanopolish HMM).
* mismatching_events: Number of events for which the model sequence was different from the reference sequence for this kmer before collapsing.
* start_idx: If nanopolish called with --signal_idx. Start coordinate on original raw signal in fast5 file
* end_idx: If nanopolish called with --signal_idx. End coordinate on original raw signal in fast5 file
* mean: If nanopolish called with --samples. Mean signal intensity based on normalized signal values provided by Nanopolish eventalign
* std: If nanopolish called with --samples. Standard deviation of signal intensity based on normalised signal values provided by Nanopolish eventalign
* n_signals: If nanopolish called with --samples. Number of signal data points
* samples: If nanopolish called with --samples and Eventalign_collapse with --write_samples. List of normalised signal intensity values for this kmer

In addition **Eventalign_collapse** also generates an useful index file containing reads level information. It contains the following fields:

* read_id: Name or index of the read
* ref_id: Name of the reference sequence the read was aligned on (contig)
* ref_start: Start coordinate of the alignment on the reference sequence
* ref_end: End coordinate of the alignment on the reference sequence
* kmers: Overall number of resquiggled kmers
* NNNNN_kmers: Number of resquiggled kmers containing at least 1 event for which the model sequence was "NNNNN"
* mismatching_kmers: Number of resquiggled kmers containing at least 1 event for which the model sequence diverged from the reference sequence
* offset: Number of characters before the start of the sequence in the main output file. **This can be used in conjunction with file.seek() to directly access the start of a read**. An example is provided in the Usage notebook.

## Usage

The package has a command line interface and a Python API.

The usage is detailed in the [usage jupyter notebook](https://nbviewer.jupyter.org/github/a-slide/NanopolishComp/blob/master/tests/NanopolishComp_usage.ipynb?flush_cache=true)


# Note to power-users and developers

Please be aware that NanopolishComp is an experimental package that is still under development. It was tested under Linux Ubuntu 16.04 and in an HPC environment running under Red Hat Enterprise 7.1.

You are welcome to contribute by requesting additional functionalities, reporting bugs or by forking and submitting patches or updates pull requests

Thank you
